import { TSchema } from '@sinclair/typebox';
import { TypeCheck } from '@sinclair/typebox/compiler';
import type { ElysiaInstance, DeepMergeTwoTypes, LifeCycleStore, LocalHook, TypedSchema, RegisteredHook } from './types';
export declare const mergeObjectArray: <T>(a: T | T[], b: T | T[]) => T[];
export declare const mergeHook: (a: LocalHook<any, any> | LifeCycleStore<any>, b: LocalHook<any, any>) => RegisteredHook<any>;
export declare const mergeDeep: <A extends Object = Object, B extends Object = Object>(target: A, source: B) => DeepMergeTwoTypes<A, B>;
export declare const getSchemaValidator: (s: TSchema | string | undefined, { models, additionalProperties, dynamic }: {
    models?: Record<string, TSchema> | undefined;
    additionalProperties?: boolean | undefined;
    dynamic?: boolean | undefined;
}) => TypeCheck<TSchema> | undefined;
export declare const getResponseSchemaValidator: (s: TypedSchema['response'] | undefined, { models, additionalProperties, dynamic }: {
    models?: Record<string, TSchema> | undefined;
    additionalProperties?: boolean | undefined;
    dynamic?: boolean | undefined;
}) => Record<number, TypeCheck<any>> | undefined;
export declare const checksum: (s: string) => number;
export declare const mergeLifeCycle: <A extends ElysiaInstance, B extends ElysiaInstance>(a: LifeCycleStore<A>, b: LifeCycleStore<B> | LocalHook<{}, B>, checksum?: number) => LifeCycleStore<A & B>;
export declare const injectLocalHookMeta: <T extends LocalHook<any, any>>(hook: T) => T;
export declare const filterInlineHook: <T extends LocalHook<any, any>>(hook: T) => T;
