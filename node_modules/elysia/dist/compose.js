import{parse as e}from"fast-querystring";import{mapEarlyResponse as r,mapResponse as t,mapCompactResponse as s}from"./handler";import{NotFoundError as n,ValidationError as a,InternalServerError as o,ERROR_CODE as c}from"./error";let i=new Headers,l=RegExp(" (\\w+) = context","g");export const hasReturn=i=>{let l=i.indexOf(")");return 61===i.charCodeAt(l+2)&&123!==i.charCodeAt(l+5)||i.includes("return")};let f=i=>({composeValidation:(e,r=`c.${e}`)=>i?`c.set.status = 400; throw new ValidationError(
'${e}',
${e},
${r}
)`:`c.set.status = 400; return new ValidationError(
	'${e}',
	${e},
	${r}
).toResponse(c.set.headers)`,composeResponseValidation:(e="r")=>i?`throw new ValidationError(
'response',
response[c.set.status],
${e}
)`:`return new ValidationError(
'response',
response[c.set.status],
${e}
).toResponse(c.set.headers)`});export const isFnUse=(i,f)=>{f=(f=f.trimStart()).replaceAll(/^async /g,"");let u=40===f.charCodeAt(0)||f.startsWith("function")?f.slice(f.indexOf("(")+1,f.indexOf(")")):f.slice(0,f.indexOf("=")-1);if(""===u)return!1;if(123===u.charCodeAt(0))return!!u.includes(i);if(f.match(RegExp(`${u}(.${i}|\\["${i}"\\])`)))return!0;let d=[u];for(let e of f.matchAll(l))d.push(e[1]);let p=RegExp(`{.*?} = (${d.join("|")})`,"g");for(let[e]of f.matchAll(p))if(e.includes(`{ ${i}`)||e.includes(`, ${i}`))return!0;return!1};export const findElysiaMeta=(i,l,f=[],u="")=>{if("object"===l.type){let e=l.properties;for(let r in e){let t=e[r],s=u?u+"."+r:r;if("object"===t.type){findElysiaMeta(i,t,f,s);continue}if(t.anyOf){for(let e of t.anyOf)findElysiaMeta(i,e,f,s);continue}t.elysiaMeta===i&&f.push(s)}return 0===f.length?null:f}return l?.elysiaMeta===i?(u&&f.push(u),"root"):null};let u=i=>{if(!i)return;let l=i?.schema;if(l&&"anyOf"in l){let e=!1,r=l.anyOf[0].type;for(let t of l.anyOf)if(t.type!==r){e=!0;break}if(!e)return r}},d=/(?:return|=>) \S*\(/g;export const isAsync=i=>{if("AsyncFunction"===i.constructor.name)return!0;let l=i.toString();return!!l.match(d)};export const composeHandler=({method:l,hooks:d,validator:p,handler:y,handleError:h,meta:$,onRequest:m,config:b})=>{let q=b.forceErrorEncapsulation||d.error.length>0||"undefined"==typeof Bun||d.onResponse.length>0,{composeValidation:g,composeResponseValidation:E}=f(q),R=d.onResponse.length?`
;(async () => {${d.onResponse.map((e,r)=>`await res${r}(c)`).join(";")}})();
`:"",w=q?"try {\n":"",x=p||"GET"!==l?[y,...d.transform,...d.beforeHandle,...d.afterHandle].map(e=>e.toString()):[],k="GET"!==l&&"none"!==d.type&&(!!p.body||!!d.type||x.some(e=>isFnUse("body",e))),H=p.headers||x.some(e=>isFnUse("headers",e));H&&(w+=i.toJSON?`c.headers = c.request.headers.toJSON()
`:`c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`);let A=p.query||x.some(e=>isFnUse("query",e));A&&(w+=`const url = c.request.url

		if(c.qi !== -1) {
			c.query ??= parseQuery(url.substring(c.qi + 1))
		} else {
			c.query ??= {}
		}
		`);let O=x.some(e=>isFnUse("set",e))||m.some(e=>isFnUse("set",e.toString())),v=k||isAsync(y)||d.parse.length>0||d.afterHandle.some(isAsync)||d.beforeHandle.some(isAsync)||d.transform.some(isAsync);if(k){let e=u(p?.body);if(d.type||e){if(d.type)switch(d.type){case"application/json":w+="c.body = await c.request.json();";break;case"text/plain":w+="c.body = await c.request.text();";break;case"application/x-www-form-urlencoded":w+="c.body = parseQuery(await c.request.text());";break;case"application/octet-stream":w+="c.body = await c.request.arrayBuffer();";break;case"multipart/form-data":w+=`c.body = {}

					const form = await c.request.formData()
					for (const key of form.keys()) {
						if (c.body[key])
							continue

						const value = form.getAll(key)
						if (value.length === 1)
							c.body[key] = value[0]
						else c.body[key] = value
					}`}else if(e){let r=p?.body?.schema;"object"===e?"URLEncoded"===r.elysiaMeta?w+="c.body = parseQuery(await c.request.text())":p.body.Code().includes("custom('File")?w+=`c.body = {}

							const form = await c.request.formData()
							for (const key of form.keys()) {
								if (c.body[key])
									continue
		
								const value = form.getAll(key)
								if (value.length === 1)
									c.body[key] = value[0]
								else c.body[key] = value
							}`:w+="c.body = JSON.parse(await c.request.text())":w+="c.body = await c.request.text()"}d.parse.length&&(w+="}}")}else{if(w+="\n"+(H?"let contentType = c.headers['content-type']":"let contentType = c.request.headers.get('content-type')")+`
            if (contentType) {
				const index = contentType.indexOf(';')
				if (index !== -1) contentType = contentType.substring(0, index)
`,d.parse.length){w+=`let used = false
`;for(let e=0;e<d.parse.length;e++){let r=`bo${e}`;0!==e&&(w+=`if(!used) {
`),w+=`let ${r} = parse[${e}](c, contentType);if(${r} instanceof Promise) ${r} = await ${r};
						if(${r} !== undefined) { c.body = ${r}; used = true }
`,0!==e&&(w+="}")}w+="if (!used)"}w+=`switch (contentType) {
			case 'application/json':
				c.body = await c.request.json()
				break

			case 'text/plain':
				c.body = await c.request.text()
				break

			case 'application/x-www-form-urlencoded':
				c.body = parseQuery(await c.request.text())
				break

			case 'application/octet-stream':
				c.body = await c.request.arrayBuffer();
				break

			case 'multipart/form-data':
				c.body = {}

				const form = await c.request.formData()
				for (const key of form.keys()) {
					if (c.body[key])
						continue

					const value = form.getAll(key)
					if (value.length === 1)
						c.body[key] = value[0]
					else c.body[key] = value
				}

				break
			}
		}
`}w+="\n"}if(p.params){let e=findElysiaMeta("Numeric",p.params.schema);if(e){if("object"==typeof e)for(let r of e)w+=`if(c.params.${r}) c.params.${r} = +c.params.${r};`;w+="\n"}}if(p.query){let e=findElysiaMeta("Numeric",p.query.schema);if(e){if("object"==typeof e)for(let r of e)w+=`if(c.query.${r}) c.query.${r} = +c.query.${r};`;w+="\n"}}if(p.headers){let e=findElysiaMeta("Numeric",p.headers.schema);if(e){if("object"==typeof e)for(let r of e)w+=`c.headers.${r} = +c.headers.${r};`;w+="\n"}}if(p.body){let e=findElysiaMeta("Numeric",p.body.schema);if(e){switch(typeof e){case"string":w+="c.body = +c.body;";break;case"object":for(let r of e)w+=`c.body.${r} = +c.body.${r};`}w+="\n"}}if(d?.transform)for(let e=0;e<d.transform.length;e++){let r=d.transform[e];"derive"===r.$elysia?w+=isAsync(d.transform[e])?`Object.assign(c, await transform[${e}](c));`:`Object.assign(c, transform[${e}](c));`:w+=isAsync(d.transform[e])?`await transform[${e}](c);`:`transform[${e}](c);`}if(p&&(p.headers&&(w+=`
                if (headers.Check(c.headers) === false) {
                    ${g("headers")}
				}
        `),p.params&&(w+=`if(params.Check(c.params) === false) { ${g("params")} }`),p.query&&(w+=`if(query.Check(c.query) === false) { ${g("query")} }`),p.body&&(w+=`if(body.Check(c.body) === false) { ${g("body")} }`)),d?.beforeHandle)for(let e=0;e<d.beforeHandle.length;e++){let r=`be${e}`,t=hasReturn(d.beforeHandle[e].toString());if(t){if(w+=(isAsync(d.beforeHandle[e])?`let ${r} = await beforeHandle[${e}](c);
`:`let ${r} = beforeHandle[${e}](c);
`)+`if(${r} !== undefined) {
`,d?.afterHandle)for(let e=0;e<d.afterHandle.length;e++){let t=hasReturn(d.afterHandle[e].toString());if(t){let t=`af${e}`;w+=(isAsync(d.afterHandle[e])?`const ${t} = await afterHandle[${e}](c, ${r});
`:`const ${t} = afterHandle[${e}](c, ${r});
`)+`if(${t} !== undefined) { ${r} = ${t} }
`}else w+=isAsync(d.afterHandle[e])?`await afterHandle[${e}](c, ${r});
`:`afterHandle[${e}](c, ${r});
`}p.response&&(w+=`if(response[c.set.status]?.Check(${r}) === false) { 
						if(!(response instanceof Error))
							${E(r)}
					}
`),w+=`return mapEarlyResponse(${r}, c.set)}
`}else w+=isAsync(d.beforeHandle[e])?`await beforeHandle[${e}](c);
`:`beforeHandle[${e}](c);
`}if(d?.afterHandle.length){w+=isAsync(y)?`let r = await handler(c);
`:`let r = handler(c);
`;for(let e=0;e<d.afterHandle.length;e++){let r=`af${e}`,t=hasReturn(d.afterHandle[e].toString());t?(w+=isAsync(d.afterHandle[e])?`let ${r} = await afterHandle[${e}](c, r)
`:`let ${r} = afterHandle[${e}](c, r)
`,p.response?w+=`if(${r} !== undefined) {if(response[c.set.status]?.Check(${r}) === false) { 
						if(!(response instanceof Error))
						${E(r)}
					}
${r} = mapEarlyResponse(${r}, c.set)
if(${r}) return ${r};
}`:w+=`if(${r}) return ${r};
`):w+=isAsync(d.afterHandle[e])?`await afterHandle[${e}](c, r)
`:`afterHandle[${e}](c, r)
`}p.response&&(w+=`if(response[c.set.status]?.Check(r) === false) { 
				if(!(response instanceof Error))
					${E()}
			}
`),O?w+=`return mapResponse(r, c.set)
`:w+=`return mapCompactResponse(r)
`}else if(p.response)w+=(isAsync(y)?`const r = await handler(c);
`:`const r = handler(c);
`)+`if(response[c.set.status]?.Check(r) === false) { 
				if(!(response instanceof Error))
					${E()}
			}
`,O?w+=`return mapResponse(r, c.set)
`:w+=`return mapCompactResponse(r)
`;else{let e=isAsync(y)?"await handler(c) ":"handler(c)";O?w+=`return mapResponse(${e}, c.set)
`:w+=`return mapCompactResponse(${e})
`}q&&(w+=`
} catch(error) {
	

	${v?"":"return (async () => {"}
		const set = c.set

		if (!set.status || set.status < 300) set.status = 500

		${d.error.length?`for (let i = 0; i < handleErrors.length; i++) {
				let handled = handleErrors[i]({
					request: c.request,
					error: error,
					set,
					code: error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
				})
				if (handled instanceof Promise) handled = await handled

				const response = mapEarlyResponse(handled, set)
				if (response) return response
			}`:""}

		return handleError(c.request, error, set)
	${v?"":"})()"}
} finally {
	${R}
}`),w=`const { 
		handler,
		handleError,
		hooks: {
			transform,
			beforeHandle,
			afterHandle,
			parse,
			error: handleErrors,
			onResponse
		},
		validator: {
			body,
			headers,
			params,
			query,
			response
		},
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError
		},
		meta,
		ERROR_CODE
	} = hooks

	${d.onResponse.length?`const ${d.onResponse.map((e,r)=>`res${r} = onResponse[${r}]`).join(",")}`:""}

	return ${v?"async":""} function(c) {
		${$?'c["schema"] = meta["schema"]; c["defs"] = meta["defs"];':""}
		${w}
	}`;let C=Function("hooks",w);return C({handler:y,hooks:d,validator:p,handleError:h,utils:{mapResponse:t,mapCompactResponse:s,mapEarlyResponse:r,parseQuery:e},error:{NotFoundError:n,ValidationError:a,InternalServerError:o},meta:$,ERROR_CODE:c})};export const composeGeneralHandler=i=>{let l="";for(let e of Object.keys(i.decorators))l+=`,${e}: app.decorators.${e}`;let{router:f,staticRouter:u}=i,d=`
	const route = find(request.method, path) ${f.root.ALL?'?? find("ALL", path)':""}
	if (route === null)
		return ${i.event.error.length?`handleError(
			request,
			notFound,
			ctx.set
		)`:`new Response(error404, {
					status: 404
				})`}

	ctx.params = route.params

	return route.store(ctx)`,p="";for(let[e,{code:r,all:t}]of Object.entries(u.map))p+=`case '${e}':
switch(request.method) {
${r}
${t??`default: ${d}`}}

`;let y=`const {
		app,
		app: { store, router, staticRouter },
		mapEarlyResponse,
		NotFoundError
	} = data

	const notFound = new NotFoundError()

	${i.event.request.length?"const onRequest = app.event.request":""}

	${u.variables}

	const find = router.find.bind(router)
	const handleError = app.handleError.bind(this)

	${i.event.error.length?"":"const error404 = notFound.message.toString()"}

	return function(request) {
	`;if(i.event.request.length){y+=`
			const ctx = {
				request,
				store,
				set: {
					headers: {},
					status: 200
				}
				${l}
			}

			try {
`;for(let e=0;e<i.event.request.length;e++){let r=hasReturn(i.event.request[e].toString());y+=r?`const response = mapEarlyResponse(
					onRequest[${e}](ctx),
					ctx.set
				)
				if (response) return response
`:`mapEarlyResponse(onRequest[${e}](ctx), ctx.set);`}y+=`} catch (error) {
			return handleError(request, error, ctx.set)
		}
		
		const url = request.url,
		s = url.indexOf('/', 11),
		i = ctx.qi = url.indexOf('?', s + 1),
		path = ctx.path = i === -1 ? url.substring(s) : url.substring(s, i);`}else y+=`
		const url = request.url,
			s = url.indexOf('/', 11),
			qi = url.indexOf('?', s + 1),
			path = qi === -1
				? url.substring(s)
				: url.substring(s, qi)

		const ctx = {
			request,
			store,
			qi,
			path,
			set: {
				headers: {},
				status: 200
			}
			${l}
		}`;return y+=`
		switch(path) {
			${p}

			default:
				${d}
		}
	}`,i.handleError=composeErrorHandler(i),Function("data",y)({app:i,mapEarlyResponse:r,NotFoundError:n})};export const composeErrorHandler=i=>{let l=`const {
		app: { event: { error: onError, onResponse: res } },
		mapResponse,
		ERROR_CODE
	} = inject

	return ${i.event.error.find(isAsync)?"async":""} function(request, error, set) {`;for(let e=0;e<i.event.error.length;e++){let r=i.event.error[e],t=`${isAsync(r)?"await ":""}onError[${e}]({
			request,
			code: error.code ?? error[ERROR_CODE] ?? 'UNKNOWN',
			error,
			set
		})`;hasReturn(r.toString())?l+=`const r${e} = ${t}; if(r${e} !== undefined) return mapResponse(r${e}, set)
`:l+=t+"\n"}return Function("inject",l+=`if(error.constructor.name === "ValidationError") {
		set.status = error.status ?? 400
		return new Response(
			error.message, 
			{ headers: set.headers, status: set.status }
		)
	} else {
		return new Response(error.message, { headers: set.headers, status: error.status ?? 500 })
	}
}`)({app:i,mapResponse:t,ERROR_CODE:c})};