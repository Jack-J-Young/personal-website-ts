"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterInlineHook = exports.injectLocalHookMeta = exports.mergeLifeCycle = exports.checksum = exports.getResponseSchemaValidator = exports.getSchemaValidator = exports.mergeDeep = exports.mergeHook = exports.mergeObjectArray = void 0;
const typebox_1 = require("@sinclair/typebox");
const value_1 = require("@sinclair/typebox/value");
const compiler_1 = require("@sinclair/typebox/compiler");
const mergeObjectArray = (a, b) => {
    const array = [...(Array.isArray(a) ? a : [a])];
    const checksums = [];
    for (const item of array) {
        if (item.$elysiaChecksum)
            checksums.push(item.$elysiaChecksum);
    }
    for (const item of Array.isArray(b) ? b : [b]) {
        if (!checksums.includes(item?.$elysiaChecksum))
            array.push(item);
    }
    return array;
};
exports.mergeObjectArray = mergeObjectArray;
const mergeHook = (a, b) => {
    return {
        body: b?.body ?? a?.body,
        headers: b?.headers ?? a?.headers,
        params: b?.params ?? a?.params,
        query: b?.query ?? a?.query,
        response: b?.response ?? a?.response,
        type: a?.type || b?.type,
        detail: (0, exports.mergeDeep)(b?.detail ?? {}, a?.detail ?? {}),
        parse: (0, exports.mergeObjectArray)(a.parse ?? [], b?.parse ?? []),
        transform: (0, exports.mergeObjectArray)(a.transform ?? [], b?.transform ?? []),
        beforeHandle: (0, exports.mergeObjectArray)(a.beforeHandle ?? [], b?.beforeHandle ?? []),
        afterHandle: (0, exports.mergeObjectArray)(a.afterHandle ?? [], b?.afterHandle ?? []),
        onResponse: (0, exports.mergeObjectArray)(a.onResponse ?? [], b?.onResponse ?? []),
        error: (0, exports.mergeObjectArray)(a.error ?? [], b?.error ?? [])
    };
};
exports.mergeHook = mergeHook;
const isObject = (item) => item && typeof item === 'object' && !Array.isArray(item);
const mergeDeep = (target, source) => {
    const output = Object.assign({}, target);
    if (isObject(target) && isObject(source)) {
        Object.keys(source).forEach((key) => {
            if (isObject(source[key])) {
                if (!(key in target))
                    Object.assign(output, { [key]: source[key] });
                else
                    output[key] = (0, exports.mergeDeep)(target[key], source[key]);
            }
            else {
                Object.assign(output, { [key]: source[key] });
            }
        });
    }
    return output;
};
exports.mergeDeep = mergeDeep;
const getSchemaValidator = (s, { models = {}, additionalProperties = false, dynamic = false }) => {
    if (!s)
        return;
    if (typeof s === 'string' && !(s in models))
        return;
    const schema = typeof s === 'string' ? models[s] : s;
    if (schema.type === 'object' && 'additionalProperties' in schema === false)
        schema.additionalProperties = additionalProperties;
    if (dynamic)
        return {
            schema,
            references: '',
            checkFunc: () => { },
            code: '',
            Check: (value) => value_1.Value.Check(schema, value),
            Errors: (value) => value_1.Value.Errors(schema, value),
            Code: () => ''
        };
    return compiler_1.TypeCompiler.Compile(schema);
};
exports.getSchemaValidator = getSchemaValidator;
const getResponseSchemaValidator = (s, { models = {}, additionalProperties = false, dynamic = false }) => {
    if (!s)
        return;
    if (typeof s === 'string' && !(s in models))
        return;
    const maybeSchemaOrRecord = typeof s === 'string' ? models[s] : s;
    const compile = (schema) => {
        if (dynamic)
            return {
                schema,
                references: '',
                checkFunc: () => { },
                code: '',
                Check: (value) => value_1.Value.Check(schema, value),
                Errors: (value) => value_1.Value.Errors(schema, value),
                Code: () => ''
            };
        return compiler_1.TypeCompiler.Compile(schema);
    };
    if (typebox_1.Kind in maybeSchemaOrRecord)
        return {
            200: compile(maybeSchemaOrRecord)
        };
    const record = {};
    Object.keys(maybeSchemaOrRecord).forEach((status) => {
        const maybeNameOrSchema = maybeSchemaOrRecord[status];
        if (typeof maybeNameOrSchema === 'string') {
            if (maybeNameOrSchema in models) {
                const schema = models[maybeNameOrSchema];
                schema.type === 'object' &&
                    'additionalProperties' in schema === false;
                record[+status] = typebox_1.Kind in schema ? compile(schema) : schema;
            }
            return undefined;
        }
        if (maybeNameOrSchema.type === 'object' &&
            'additionalProperties' in maybeNameOrSchema === false)
            maybeNameOrSchema.additionalProperties = additionalProperties;
        record[+status] =
            typebox_1.Kind in maybeNameOrSchema
                ? compile(maybeNameOrSchema)
                : maybeNameOrSchema;
    });
    return record;
};
exports.getResponseSchemaValidator = getResponseSchemaValidator;
const checksum = (s) => {
    let h = 9;
    for (let i = 0; i < s.length;)
        h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9);
    return (h = h ^ (h >>> 9));
};
exports.checksum = checksum;
const mergeLifeCycle = (a, b, checksum) => {
    const injectChecksum = (x) => {
        if (checksum)
            x.$elysiaChecksum = checksum;
        return x;
    };
    return {
        start: (0, exports.mergeObjectArray)(a.start, ('start' in b ? b.start : []).map(injectChecksum)),
        request: (0, exports.mergeObjectArray)(a.request, ('request' in b ? b.request : []).map(injectChecksum)),
        parse: (0, exports.mergeObjectArray)(a.parse, b?.parse ?? []).map(injectChecksum),
        transform: (0, exports.mergeObjectArray)(a.transform, (b?.transform ?? []).map(injectChecksum)),
        beforeHandle: (0, exports.mergeObjectArray)(a.beforeHandle, (b?.beforeHandle ?? []).map(injectChecksum)),
        afterHandle: (0, exports.mergeObjectArray)(a.afterHandle, (b?.afterHandle ?? []).map(injectChecksum)),
        onResponse: (0, exports.mergeObjectArray)(a.onResponse, (b?.onResponse ?? []).map(injectChecksum)),
        error: (0, exports.mergeObjectArray)(a.error, (b?.error ?? []).map(injectChecksum)),
        stop: (0, exports.mergeObjectArray)(a.stop, ('stop' in b ? b.stop : []).map(injectChecksum))
    };
};
exports.mergeLifeCycle = mergeLifeCycle;
const injectInline = (fn) => {
    if (!fn)
        return fn;
    if (typeof fn === 'function') {
        fn.$elysiaHookType = 'inline';
        return fn;
    }
    return fn.map((x) => {
        x.$elysiaHookType = 'inline';
        return x;
    });
};
const injectLocalHookMeta = (hook) => {
    return {
        ...hook,
        type: hook?.type,
        detail: hook?.detail,
        parse: injectInline(hook?.parse),
        transform: injectInline(hook?.transform),
        beforeHandle: injectInline(hook?.beforeHandle),
        afterHandle: injectInline(hook?.afterHandle),
        onResponse: injectInline(hook?.onResponse),
        error: injectInline(hook?.error)
    };
};
exports.injectLocalHookMeta = injectLocalHookMeta;
const filterInline = (fn) => {
    if (!fn)
        return fn;
    if (typeof fn === 'function') {
        return fn.$elysiaHookType === 'inline' ? fn : undefined;
    }
    return fn.filter((x) => x.$elysiaHookType === 'inline');
};
const filterInlineHook = (hook) => {
    return {
        ...hook,
        type: hook?.type,
        detail: hook?.detail,
        parse: filterInline(hook?.parse),
        transform: filterInline(hook?.transform),
        beforeHandle: filterInline(hook?.beforeHandle),
        afterHandle: filterInline(hook?.afterHandle),
        onResponse: filterInline(hook?.onResponse),
        error: filterInline(hook?.error)
    };
};
exports.filterInlineHook = filterInlineHook;
