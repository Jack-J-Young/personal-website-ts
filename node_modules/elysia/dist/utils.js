import{Kind as e}from"@sinclair/typebox";import{Value as r}from"@sinclair/typebox/value";import{TypeCompiler as t}from"@sinclair/typebox/compiler";export const mergeObjectArray=(o,a)=>{let n=[...Array.isArray(o)?o:[o]],s=[];for(let e of n)e.$elysiaChecksum&&s.push(e.$elysiaChecksum);for(let e of Array.isArray(a)?a:[a])s.includes(e?.$elysiaChecksum)||n.push(e);return n};export const mergeHook=(o,a)=>({body:a?.body??o?.body,headers:a?.headers??o?.headers,params:a?.params??o?.params,query:a?.query??o?.query,response:a?.response??o?.response,type:o?.type||a?.type,detail:mergeDeep(a?.detail??{},o?.detail??{}),parse:mergeObjectArray(o.parse??[],a?.parse??[]),transform:mergeObjectArray(o.transform??[],a?.transform??[]),beforeHandle:mergeObjectArray(o.beforeHandle??[],a?.beforeHandle??[]),afterHandle:mergeObjectArray(o.afterHandle??[],a?.afterHandle??[]),onResponse:mergeObjectArray(o.onResponse??[],a?.onResponse??[]),error:mergeObjectArray(o.error??[],a?.error??[])});let o=o=>o&&"object"==typeof o&&!Array.isArray(o);export const mergeDeep=(a,n)=>{let s=Object.assign({},a);return o(a)&&o(n)&&Object.keys(n).forEach(e=>{o(n[e])&&e in a?s[e]=mergeDeep(a[e],n[e]):Object.assign(s,{[e]:n[e]})}),s};export const getSchemaValidator=(o,{models:a={},additionalProperties:n=!1,dynamic:s=!1})=>{if(!o||"string"==typeof o&&!(o in a))return;let p="string"==typeof o?a[o]:o;return("object"===p.type&&"additionalProperties"in p==!1&&(p.additionalProperties=n),s)?{schema:p,references:"",checkFunc:()=>{},code:"",Check:e=>r.Check(p,e),Errors:e=>r.Errors(p,e),Code:()=>""}:t.Compile(p)};export const getResponseSchemaValidator=(o,{models:a={},additionalProperties:n=!1,dynamic:s=!1})=>{if(!o||"string"==typeof o&&!(o in a))return;let p="string"==typeof o?a[o]:o,i=e=>s?{schema:e,references:"",checkFunc:()=>{},code:"",Check:t=>r.Check(e,t),Errors:t=>r.Errors(e,t),Code:()=>""}:t.Compile(e);if(e in p)return{200:i(p)};let l={};return Object.keys(p).forEach(r=>{let t=p[r];if("string"==typeof t){if(t in a){let o=a[t];o.type,l[+r]=e in o?i(o):o}return}"object"===t.type&&"additionalProperties"in t==!1&&(t.additionalProperties=n),l[+r]=e in t?i(t):t}),l};export const checksum=o=>{let a=9;for(let e=0;e<o.length;)a=Math.imul(a^o.charCodeAt(e++),387420489);return a^a>>>9};export const mergeLifeCycle=(o,a,n)=>{let s=e=>(n&&(e.$elysiaChecksum=n),e);return{start:mergeObjectArray(o.start,("start"in a?a.start:[]).map(s)),request:mergeObjectArray(o.request,("request"in a?a.request:[]).map(s)),parse:mergeObjectArray(o.parse,a?.parse??[]).map(s),transform:mergeObjectArray(o.transform,(a?.transform??[]).map(s)),beforeHandle:mergeObjectArray(o.beforeHandle,(a?.beforeHandle??[]).map(s)),afterHandle:mergeObjectArray(o.afterHandle,(a?.afterHandle??[]).map(s)),onResponse:mergeObjectArray(o.onResponse,(a?.onResponse??[]).map(s)),error:mergeObjectArray(o.error,(a?.error??[]).map(s)),stop:mergeObjectArray(o.stop,("stop"in a?a.stop:[]).map(s))}};let a=o=>o?"function"==typeof o?(o.$elysiaHookType="inline",o):o.map(e=>(e.$elysiaHookType="inline",e)):o;export const injectLocalHookMeta=o=>({...o,type:o?.type,detail:o?.detail,parse:a(o?.parse),transform:a(o?.transform),beforeHandle:a(o?.beforeHandle),afterHandle:a(o?.afterHandle),onResponse:a(o?.onResponse),error:a(o?.error)});let n=o=>o?"function"==typeof o?"inline"===o.$elysiaHookType?o:void 0:o.filter(e=>"inline"===e.$elysiaHookType):o;export const filterInlineHook=o=>({...o,type:o?.type,detail:o?.detail,parse:n(o?.parse),transform:n(o?.transform),beforeHandle:n(o?.beforeHandle),afterHandle:n(o?.afterHandle),onResponse:n(o?.onResponse),error:n(o?.error)});